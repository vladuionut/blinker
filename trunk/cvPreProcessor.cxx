#include "stdafx.h"
//
// cvPreProcessor, GUI tool for OpenCv
// Copyright (C) 2008  BlueKid
// GUI tool for OpenCv 
// Programmed by BlueKid");
//  http://derindelimavi.blogspot.com/");
// Please Send me any suggestion, modification or bugs.");
// Don't hesitate to contact me for any question");
// I will be very grateful with your feedbacks.");
// bluekid70@gmail.com
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//

// generated by Fast Light User Interface Designer (fluid) version 1.0109

#include "cvPreProcessor.h"
IplImage *img,*pimg,*timg; 
IplImage *mimg; 
Fl_OpenCV *orj,*proc; 
Processor *p; 

Fl_Group *Before=(Fl_Group *)0;

Fl_Group *After=(Fl_Group *)0;

static void cb_(Fl_Button*, void*) {
  p->CopyTo1();
}

static void cb_1(Fl_Button*, void*) {
  p->Load1();
}

Fl_Button *MemorySet1=(Fl_Button *)0;

static void cb_MemorySet1(Fl_Button*, void*) {
  p->CopyToMemory(1);
MemoryGet1->activate();
MemoryGet2->activate();
}

Fl_Button *MemoryGet1=(Fl_Button *)0;

static void cb_MemoryGet1(Fl_Button*, void*) {
  p->CopyFromMemory(1);
}

Fl_Button *MemorySet2=(Fl_Button *)0;

static void cb_MemorySet2(Fl_Button*, void*) {
  p->CopyToMemory(2);
MemoryGet1->activate();
MemoryGet2->activate();
}

static void cb_2(Fl_Button*, void*) {
  p->Load2();
}

Fl_Button *MemoryGet2=(Fl_Button *)0;

static void cb_MemoryGet2(Fl_Button*, void*) {
  p->CopyFromMemory(2);
}

static void cb_Open(Fl_Menu_*, void*) {
  p->Load1();
}

static void cb_Save(Fl_Menu_*, void*) {
  p->Save1();
}

static void cb_Open1(Fl_Menu_*, void*) {
  p->Load2();
}

static void cb_Save1(Fl_Menu_*, void*) {
  p->Save2();
}

static void cb_Clear(Fl_Menu_*, void*) {
  p->Clear();
}

static void cb_Undo(Fl_Menu_*, void*) {
  p->Undo();
}

static void cb_Save2(Fl_Menu_*, void*) {
  p->SaveCode();
}

static void cb_Exit(Fl_Menu_*, void*) {
  exit(0);
}

static void cb_Resize(Fl_Menu_*, void*) {
  if(img==NULL)   return;  
ReSizeForm *op=new ReSizeForm();
op->show();
}

static void cb_Histogram(Fl_Menu_*, void*) {
  if(img==NULL)   return;  
HistForm *op=new HistForm();
op->show();
}

static void cb_RGB(Fl_Menu_*, void*) {
  p->RGBToGray();
}

static void cb_Split(Fl_Menu_*, void*) {
  p->SRed();
}

static void cb_Split1(Fl_Menu_*, void*) {
  p->SGreen();
}

static void cb_Split2(Fl_Menu_*, void*) {
  p->SBlue();
}

static void cb_Split3(Fl_Menu_*, void*) {
  p->SHue();
}

static void cb_Split4(Fl_Menu_*, void*) {
  p->SSaturation();
}

static void cb_Equalizes(Fl_Menu_*, void*) {
  p->EHist();
}

static void cb_Normal(Fl_Menu_*, void*) {
  p->NormalThreshold();
}

static void cb_Adaptive(Fl_Menu_*, void*) {
  p->AdaptiveThreshold();
}

static void cb_Options(Fl_Menu_*, void*) {
  ThresholdOptions *op=new ThresholdOptions();
op->show();
}

static void cb_Erode(Fl_Menu_*, void*) {
  p->Erode();
}

static void cb_Dilate(Fl_Menu_*, void*) {
  p->Dilate();
}

static void cb_Open2(Fl_Menu_*, void*) {
  p->Open();
}

static void cb_Close(Fl_Menu_*, void*) {
  p->Close();
}

static void cb_Gradient(Fl_Menu_*, void*) {
  p->Grad();
}

static void cb_Top(Fl_Menu_*, void*) {
  p->TopHat();
}

static void cb_Black(Fl_Menu_*, void*) {
  p->BlackHat();
}

static void cb_Options1(Fl_Menu_*, void*) {
  MorphOptions *op=new MorphOptions();
op->show();
}

static void cb_Sobel(Fl_Menu_*, void*) {
  p->Sobel();
}

static void cb_Laplace(Fl_Menu_*, void*) {
  p->Laplace();
}

static void cb_Canny(Fl_Menu_*, void*) {
  p->Canny();
}

static void cb_Options2(Fl_Menu_*, void*) {
  EdgeOptions *op=new EdgeOptions();
op->show();
}

static void cb_Add(Fl_Menu_*, void*) {
  p->Add();
}

static void cb_Subtract(Fl_Menu_*, void*) {
  p->Sub();
}

static void cb_Multiply(Fl_Menu_*, void*) {
  p->Mul();
}

static void cb_Division(Fl_Menu_*, void*) {
  p->Div();
}

static void cb_Max(Fl_Menu_*, void*) {
  p->Max();
}

static void cb_Min(Fl_Menu_*, void*) {
  p->Div();
}

static void cb_Absolute(Fl_Menu_*, void*) {
  p->AbsDiff();
}

static void cb_Equal(Fl_Menu_*, void*) {
  p->Compare(0);
}

static void cb_Greater(Fl_Menu_*, void*) {
  p->Compare(1);
}

static void cb_Greater1(Fl_Menu_*, void*) {
  p->Compare(2);
}

static void cb_Less(Fl_Menu_*, void*) {
  p->Compare(3);
}

static void cb_Less1(Fl_Menu_*, void*) {
  p->Compare(4);
}

static void cb_Not(Fl_Menu_*, void*) {
  p->Compare(5);
}

static void cb_And(Fl_Menu_*, void*) {
  p->And();
}

static void cb_Or(Fl_Menu_*, void*) {
  p->Or();
}

static void cb_Xor(Fl_Menu_*, void*) {
  p->Xor();
}

static void cb_Not1(Fl_Menu_*, void*) {
  p->Not();
}

static void cb_About(Fl_Menu_*, void*) {
  AboutDlg *ab=new AboutDlg();
ab->show();
}

Fl_Menu_Item menu_[] = {
 {"File", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Open Image 1", 0,  (Fl_Callback*)cb_Open, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Save  Image 1", 0,  (Fl_Callback*)cb_Save, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Open Image 2", 0,  (Fl_Callback*)cb_Open1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Save  Image 2", 0,  (Fl_Callback*)cb_Save1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Clear All", 0,  (Fl_Callback*)cb_Clear, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Undo", 0xff08,  (Fl_Callback*)cb_Undo, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Save Code", 0,  (Fl_Callback*)cb_Save2, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Exit", 0,  (Fl_Callback*)cb_Exit, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Image", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Resize", 0,  (Fl_Callback*)cb_Resize, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Rotate", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Histogram", 0,  (Fl_Callback*)cb_Histogram, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Color", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"RGB To Gray", 0,  (Fl_Callback*)cb_RGB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Split Red", 0,  (Fl_Callback*)cb_Split, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Split Green", 0,  (Fl_Callback*)cb_Split1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Split Blue", 0,  (Fl_Callback*)cb_Split2, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Split Hue", 0,  (Fl_Callback*)cb_Split3, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Split Saturation", 0,  (Fl_Callback*)cb_Split4, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Equalizes histogram", 0,  (Fl_Callback*)cb_Equalizes, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Threshold", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Normal", 0,  (Fl_Callback*)cb_Normal, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Adaptive", 0,  (Fl_Callback*)cb_Adaptive, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Options", 0,  (Fl_Callback*)cb_Options, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0},
 {"Morphology", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Erode", 0,  (Fl_Callback*)cb_Erode, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Dilate", 0,  (Fl_Callback*)cb_Dilate, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Open", 0,  (Fl_Callback*)cb_Open2, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Close", 0,  (Fl_Callback*)cb_Close, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Gradient", 0,  (Fl_Callback*)cb_Gradient, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Top hat", 0,  (Fl_Callback*)cb_Top, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Black hat", 0,  (Fl_Callback*)cb_Black, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Options", 0,  (Fl_Callback*)cb_Options1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Edge Detections", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Sobel", 0,  (Fl_Callback*)cb_Sobel, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Laplace", 0,  (Fl_Callback*)cb_Laplace, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Canny", 0,  (Fl_Callback*)cb_Canny, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Options", 0,  (Fl_Callback*)cb_Options2, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Arithmetical", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Add", 0x8002b,  (Fl_Callback*)cb_Add, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Subtract", 0x8002d,  (Fl_Callback*)cb_Subtract, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Multiply", 0x8002a,  (Fl_Callback*)cb_Multiply, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Division", 0x8002f,  (Fl_Callback*)cb_Division, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Max", 0,  (Fl_Callback*)cb_Max, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Min", 0,  (Fl_Callback*)cb_Min, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Absolute Diff", 0,  (Fl_Callback*)cb_Absolute, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Compare", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Equal to", 0,  (Fl_Callback*)cb_Equal, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Greater than", 0,  (Fl_Callback*)cb_Greater, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Greater or Equal", 0,  (Fl_Callback*)cb_Greater1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Less than", 0,  (Fl_Callback*)cb_Less, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Less or Equal", 0,  (Fl_Callback*)cb_Less1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Not Equal to", 0,  (Fl_Callback*)cb_Not, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0},
 {"Logical", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"And", 0,  (Fl_Callback*)cb_And, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Or", 0,  (Fl_Callback*)cb_Or, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Xor", 0,  (Fl_Callback*)cb_Xor, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Not", 0,  (Fl_Callback*)cb_Not1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Help", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"About", 0,  (Fl_Callback*)cb_About, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0}
};

Fl_Browser *Output=(Fl_Browser *)0;

Fl_Double_Window* make_window() {
  Fl_Double_Window* w;
  { Fl_Double_Window* o = new Fl_Double_Window(1064, 678, "OpenCv GUI Tool  0.8");
    w = o;
    o->color((Fl_Color)31);
    { Fl_Group* o = new Fl_Group(10, 50, 1044, 364);
      { Before = new Fl_Group(10, 50, 484, 364, "Image 1 ( img )");
        Before->box(FL_EMBOSSED_BOX);
        Before->color((Fl_Color)31);
        Before->align(FL_ALIGN_TOP_LEFT);
        orj=new Fl_OpenCV(12,52,480,320);
        orj->FitWindows();
        Before->end();
      } // Fl_Group* Before
      { After = new Fl_Group(570, 50, 484, 364, "Image 2 ( pimg )");
        After->box(FL_EMBOSSED_BOX);
        After->color((Fl_Color)31);
        After->align(FL_ALIGN_TOP_LEFT);
        proc=new Fl_OpenCV(572,52,480,320);
        proc->FitWindows();
        After->end();
      } // Fl_Group* After
      { Fl_Button* o = new Fl_Button(505, 210, 55, 26, "@<-");
        o->box(FL_GTK_UP_BOX);
        o->color((Fl_Color)21);
        o->labelcolor((Fl_Color)3);
        o->callback((Fl_Callback*)cb_);
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(495, 50, 30, 20, "...");
        o->tooltip("Open File");
        o->box(FL_GTK_THIN_UP_BOX);
        o->color((Fl_Color)21);
        o->callback((Fl_Callback*)cb_1);
      } // Fl_Button* o
      { MemorySet1 = new Fl_Button(495, 81, 30, 25, "@-> M");
        MemorySet1->tooltip("Copy to Memory");
        MemorySet1->box(FL_GTK_THIN_UP_BOX);
        MemorySet1->color((Fl_Color)21);
        MemorySet1->labelsize(10);
        MemorySet1->labelcolor((Fl_Color)1);
        MemorySet1->callback((Fl_Callback*)cb_MemorySet1);
      } // Fl_Button* MemorySet1
      { MemoryGet1 = new Fl_Button(495, 116, 30, 25, "@<-  M");
        MemoryGet1->tooltip("Copy form Memory");
        MemoryGet1->box(FL_GTK_THIN_UP_BOX);
        MemoryGet1->color((Fl_Color)21);
        MemoryGet1->labelsize(10);
        MemoryGet1->labelcolor((Fl_Color)1);
        MemoryGet1->callback((Fl_Callback*)cb_MemoryGet1);
        MemoryGet1->deactivate();
      } // Fl_Button* MemoryGet1
      { MemorySet2 = new Fl_Button(540, 285, 30, 25, "M @<-");
        MemorySet2->tooltip("Copy to Memory");
        MemorySet2->box(FL_GTK_THIN_UP_BOX);
        MemorySet2->color((Fl_Color)21);
        MemorySet2->labelsize(10);
        MemorySet2->labelcolor((Fl_Color)1);
        MemorySet2->callback((Fl_Callback*)cb_MemorySet2);
      } // Fl_Button* MemorySet2
      { Fl_Button* o = new Fl_Button(540, 260, 30, 20, "...");
        o->tooltip("Open File");
        o->box(FL_GTK_THIN_UP_BOX);
        o->color((Fl_Color)21);
        o->callback((Fl_Callback*)cb_2);
      } // Fl_Button* o
      { MemoryGet2 = new Fl_Button(540, 315, 30, 25, "M @->");
        MemoryGet2->tooltip("Copy form Memory");
        MemoryGet2->box(FL_GTK_THIN_UP_BOX);
        MemoryGet2->color((Fl_Color)21);
        MemoryGet2->labelsize(10);
        MemoryGet2->labelcolor((Fl_Color)1);
        MemoryGet2->callback((Fl_Callback*)cb_MemoryGet2);
        MemoryGet2->deactivate();
      } // Fl_Button* MemoryGet2
      o->end();
    } // Fl_Group* o
    { Fl_Menu_Bar* o = new Fl_Menu_Bar(0, 0, 1064, 25);
      o->box(FL_GTK_UP_BOX);
      o->color((Fl_Color)19);
      o->menu(menu_);
    } // Fl_Menu_Bar* o
    { Output = new Fl_Browser(10, 424, 1044, 244);
      Output->type(3);
      Output->box(FL_DOWN_BOX);
      Output->color((Fl_Color)19);
    } // Fl_Browser* Output
    o->end();
  } // Fl_Double_Window* o
  return w;
}

//int main(int argc, char **argv) {
//  /*Fl_Window  * window;
//  img=0;
//  window = make_window( );
//  window->show( argc, argv );
//  p= new Processor();
//  return Fl::run();*/
//}

Processor::Processor() {
  m.iterations=1;
  m.cols=3;
  m.rows=3;
  m.anchor_x=2;
  m.anchor_y=2;
  m.shape=CV_SHAPE_RECT;

  ed.aperture=0;
  ed.xOrder=1;
  ed.yOrder=0;
  ed.tmin=50;
  ed.tmax=150;

  th.thresh=128;
  th.maxVal=255;
  th.type=CV_THRESH_BINARY;
  th.method=CV_ADAPTIVE_THRESH_MEAN_C;
  th.block_size=3;
  th.param1=5;
  th.otsu=0;
  r.ratio=100;  
  r.rwidth=0;
  r.rheight=0;  
  r.aspect=1;
  
  uimg=NULL;
  upimg=NULL;
  undo=false;
  
  
  
  Clear();
}

void Processor::FixFilename(char *src, char *dst) {
  int j=0;
  for(int i=0; i<1024 ;i++){
    dst[j]=src[i];
    j++;
    if(src[i]==0) break;
    if(src[i]=='/') dst[j++]='/';
   
  }
}

void Processor::CopyTo1() {
  if(pimg){
    img=cvCloneImage(pimg);
    orj->SetImage(img);
    Before->redraw();
  
    Output->add("");
    Output->add("/* Copy Image2 to Image1 */");
    Output->add("  if(img)"); 
    Output->add("    cvReleaseImage(&img);");
    Output->add("  img=cvCloneImage(pimg);"); 
    Output->bottomline(Output->size());
  }
}

void Processor::CopyFromMemory(int i) {
  if(i==1){ 
    if(mimg){
      img=cvCloneImage(mimg);
      orj->SetImage(img);
      Before->redraw();
  
      Output->add("");
      Output->add("/* Copy from Memory to Image1 */");
      Output->add("  if(img)"); 
      Output->add("    cvReleaseImage(&img);");
      Output->add("  img=cvCloneImage(mimg);"); 
      Output->bottomline(Output->size());
    }
  }  
  else{ 
    if(mimg){
      pimg=cvCloneImage(mimg);
      proc->SetImage(pimg);
      After->redraw();
  
      Output->add("");
      Output->add("/* Copy from Memory to Image2 */");
      Output->add("  if(pimg)"); 
      Output->add("    cvReleaseImage(&pimg);");
      Output->add("  pimg=cvCloneImage(mimg);"); 
      Output->bottomline(Output->size());
    }
  }
}

void Processor::CopyToMemory(int i) {
  if(i==1){ 
    if(img){
      mimg=cvCloneImage(img);   
      Output->add("");
      Output->add("/* Copy Image1 to Memory */");
      Output->add("  if(mimg)"); 
      Output->add("    cvReleaseImage(&mimg);");
      Output->add("  mimg=cvCloneImage(img);"); 
      Output->bottomline(Output->size());
    }
  }
  else{
    if(pimg){
      mimg=cvCloneImage(pimg);   
      Output->add("");
      Output->add("/* Copy Image2 to Memory */");
      Output->add("  if(mimg)"); 
      Output->add("    cvReleaseImage(&mimg);");
      Output->add("  mimg=cvCloneImage(pimg);"); 
      Output->bottomline(Output->size());
    }
  }
}

void Processor::SaveState() {
  usize=Output->size();
  if(uimg)
    cvReleaseImage(&uimg);
  if(upimg)
    cvReleaseImage(&upimg);  
  
  if(img)
    uimg=cvCloneImage(img);
  if(pimg) 
    upimg=cvCloneImage(pimg);
  undo=true;
}

void Processor::Undo() {
  if(undo==false) return;
// if(uimg){
    img=uimg;
    orj->SetImage(img);
    Before->redraw();
    uimg=NULL;
//  }
//  if(upimg){
    pimg=upimg;
    proc->SetImage(pimg);
    After->redraw();
    upimg=NULL;
//  }

//  if(usize){  
    while(usize < Output->size())
       Output->remove(Output->size());
    usize=0;
//  }
  undo=false;
  
  Output->bottomline(Output->size());
}

void Processor::Load1() {
  char* file;

  file = fl_file_chooser("Open", "Picture (*.{jpg,png,bmp,dib,sr,ras,pbm,pgm,ppm,tif,tiff})\t", 0);
  if(file==NULL) return;

  SaveState();
  orj->Load(file, CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR ); 
  img=orj->image;
// Board->redraw();
  Before->redraw();


  char Buf[1024];
  char Buf2[1024];
  Output->add("");
  Output->add("/* Loads Images */");
  Output->add("  if(img)"); 
  Output->add("    cvReleaseImage(&img);");
  sprintf(Buf,"  img=cvLoadImage( %c%s %c, CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR  );",'"',file,'"');
  FixFilename(Buf,Buf2);
  Output->add(Buf2);
  Output->bottomline(Output->size());
}

void Processor::Save1() {
  if(!img) return;
  char* file=NULL;
  file = fl_file_chooser("Save", "Picture (*.{jpg,png,bmp,dib,sr,ras,pbm,pgm,ppm,tif,tiff})\t", 0);
  if(file==NULL) return;
  orj->Save(file);

  char Buf[1024];
  Output->add("");
  Output->add("/* Save Image */");
  sprintf(Buf,"  cvSaveImage( %c %s %c,img );",'"',file,'"');
  Output->add(Buf);
  Output->bottomline(Output->size());
}

void Processor::Load2() {
  char* file;

  file = fl_file_chooser("Open", "Picture (*.{jpg,png,bmp,dib,sr,ras,pbm,pgm,ppm,tif,tiff})\t", 0);
  if(file==NULL) return;
  SaveState();
  proc->Load(file, CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR ); 
  pimg=proc->image;
  After->redraw();

  
  char Buf[1024];
  char Buf2[1024];
  Output->add("");
  Output->add("/* Loads Images */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  sprintf(Buf,"  pimg=cvLoadImage( %c%s %c, CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR  );",'"',file,'"');
  FixFilename(Buf,Buf2);
  Output->add(Buf2);
  Output->bottomline(Output->size());
}

void Processor::Save2() {
  if(!pimg) return;
  char* file=NULL;
  file = fl_file_chooser("Save", "Picture (*.{jpg,png,bmp,dib,sr,ras,pbm,pgm,ppm,tif,tiff})\t", 0);
  if(file==NULL) return;
  proc->Save(file);

  char Buf[1024];
  Output->add("");
  Output->add("/* Save Image */");
  sprintf(Buf,"  cvSaveImage( %c %s %c,pimg );",'"',file,'"');
  Output->add(Buf);
  Output->bottomline(Output->size());
}

void Processor::Clear() {
  orj->SetImage(NULL);
  proc->SetImage(NULL);
  Before->redraw();
  After->redraw();
  Output->clear();
  Output->clear();
  char Buf[512];
  Output->add("/* This Code generated by cvPreprocessor ver 0.7 */");
  Output->add("#include <cv.h>");
  Output->add("#include <highgui.h>");
  Output->add("");
  Output->add("IplImage* img,*pimg,*timg,*mimg;");
  Output->add("void Process();");
  Output->add("");
  Output->add("int main( )");
  Output->add("{");
  Output->add("   Process();");
  Output->add("   if(img){");
  sprintf(Buf,"     cvNamedWindow( %cSource%c, 1 );",'"','"');
  Output->add(Buf);
  sprintf(Buf,"     cvShowImage( %cSource%c, img );",'"','"');
  Output->add(Buf);
  Output->add("   }");
  Output->add("   if(pimg){");
  sprintf(Buf,"     cvNamedWindow( %cProcessed Image%c, 1 );",'"','"');
  Output->add(Buf);
  sprintf(Buf,"     cvShowImage( %cProcessed Image%c, pimg );",'"','"');
  Output->add(Buf);
  Output->add("   }");
  Output->add("   cvWaitKey(0);");
  Output->add("");
  Output->add("   if(img)");
  Output->add("     cvReleaseImage(&img);");
  Output->add("   if(pimg)");
  Output->add("     cvReleaseImage(&pimg);");
  Output->add("");
  Output->add("}");
  Output->add("void Process()");
  Output->add("{");
  Output->bottomline(Output->size());
}

void Processor::SaveCode() {
  if(Output->size()<1) return;
  char* file=NULL;
  file = fl_file_chooser("Save Code ", "Code (*.{c,cpp,cxx,}\t", 0);
  if(file==NULL) return;

  if(file!=NULL){
    char Buf[1024];
    FILE *fp;
    fp=fopen(file,"wt");
    if(fp){
     for(int i=1;i<=Output->size();i++){
       sprintf(Buf,"%s\n",Output->text(i));
       fputs(Buf,fp);
     }
     fputs("}",fp);
     fclose(fp);   
     fl_message("Code Saved");      
    }

  }
}

void Processor::Exit() {
  exit(0);
}

void Processor::ReSize() {
  if(img==NULL)   return;  




  SaveState();
  pimg = cvCreateImage( cvSize(r.rwidth,r.rheight), img->depth, img->nChannels);

  cvResize( img, pimg, r.method);
  proc->SetImage(pimg);
  After->redraw();
  

  char *Methods[]= {"CV_INTER_NN",
 	            "CV_INTER_LINEAR",
		    "CV_INTER_AREA",
		    "CV_INTER_CUBIC"};
  char Buf[512];  
  
  Output->add(""); 
  Output->add("/* Resizing image  */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  sprintf(Buf,"  pimg = cvCreateImage( cvSize(%d,%d), %d, %d);",r.rwidth,r.rheight, img->depth, img->nChannels);
  Output->add(Buf);
  sprintf(Buf,"  cvResize( img, pimg, %s);",Methods[r.method]);
  Output->add(Buf);  
  Output->bottomline(Output->size());
}

void Processor::RGBToGray() {
  if(img==NULL)   return;  
  if(img->nChannels!=3){ 
     fl_alert("image must be color");
     return;  
  }

  SaveState();
  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );
  cvCvtColor( img, pimg, CV_RGB2GRAY );
  proc->SetImage(pimg);
  After->redraw();
  Output->add(""); 
  Output->add("/* Converts image from color space ( RGB ) to a Gray Scale */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );");
  Output->add("  cvCvtColor( img, pimg, CV_RGB2GRAY );");
  Output->bottomline(Output->size());
}

void Processor::SRed() {
  if(img==NULL)   return;  
  if(img->nChannels!=3){ 
     fl_alert("image must be color");
     return;  
  }

  SaveState();  
  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );
  cvSplit( img,pimg,0,0,0);
  proc->SetImage(pimg);
  After->redraw();
  Output->add(""); 
  Output->add("/* Split Red Channel of image to a Gray Scale image */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );");
  Output->add("  cvSplit( img,0,0,pimg,0);");
  Output->bottomline(Output->size());
}

void Processor::SGreen() {
  if(img==NULL)   return;  
  if(img->nChannels!=3){ 
     fl_alert("image must be color");
     return;  
  }

  SaveState();  
  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );
  cvSplit( img,0,pimg,0,0);
  proc->SetImage(pimg);
  After->redraw();
  Output->add(""); 
  Output->add("/* Split Green Channel of image to a Gray Scale image */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );");
  Output->add("  cvSplit( img,0,pimg,0,0);");
  Output->bottomline(Output->size());
}

void Processor::SBlue() {
  if(img==NULL)   return;  
  if(img->nChannels!=3){ 
     fl_alert("image must be color");
     return;  
  }

  SaveState();  
  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );
  cvSplit( img,0,0,pimg,0);
  proc->SetImage(pimg);
  After->redraw();
  Output->add(""); 
  Output->add("/* Split Blue Channel of image to a Gray Scale image */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );");
  Output->add("  cvSplit( img,pimg,0,0,0);");
  Output->bottomline(Output->size());
}

void Processor::SHue() {
  if(img==NULL)   return;  
  if(img->nChannels!=3){ 
     fl_alert("image must be color");
     return;  
  }

  SaveState();  
  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );
  timg = cvCreateImage( cvGetSize(img), 8, 3 );
  cvCvtColor( img, timg, CV_RGB2HSV );
  cvConvertScale(timg,timg, 255/180 ,0);
  cvSplit( timg,pimg,0,0,0);
  cvReleaseImage(&timg);
  proc->SetImage(pimg);
  After->redraw();

  Output->add(""); 
  Output->add("/* Split Hue Channel from HSV image to a Gray Scale image */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );");
  Output->add("  timg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 3 );");
  Output->add("  cvCvtColor( img, timg, CV_BGR2HSV );");
  Output->add("  cvConvertScale(timg,timg, 255.0/180.0 ,0);");
  Output->add("  cvSplit( timg,pimg,0,0,0);");
  Output->add("  cvReleaseImage(&timg);");
  Output->bottomline(Output->size());
}

void Processor::SSaturation() {
  if(img==NULL)   return;  
  if(img->nChannels!=3){ 
     fl_alert("image must be color");
     return;  
  }

  SaveState();  
  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );
  timg = cvCreateImage( cvGetSize(img), 8, 3 );
  cvCvtColor( img, timg, CV_RGB2HSV );
  cvSplit( timg,0,pimg,0,0);
  cvReleaseImage(&timg);

  proc->SetImage(pimg);
  After->redraw();
  Output->add(""); 
  Output->add("/* Split Saturation Channel from HSV to a Gray Scale image */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );");
  Output->add("  timg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 3 );");
  Output->add("  cvCvtColor( img, timg, CV_BGR2HSV );");
  Output->add("  cvSplit( timg,0,pimg,0,0);");
  Output->add("  cvReleaseImage(&timg);");
  Output->bottomline(Output->size());
}

void Processor::EHist() {
  if(img==NULL)   return;  
  if(img->nChannels!=1){ 
     fl_alert("image must be a gray and single channel ");
     return;  
  }

  SaveState();  
  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );
  cvEqualizeHist(img,pimg );
  proc->SetImage(pimg);
  After->redraw();
  Output->add(""); 
  Output->add("/* Equalizes histogram of grayscale image */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );");
  Output->add("  cvEqualizeHist(img,pimg);");
  Output->bottomline(Output->size());
}

void Processor::NormalThreshold() {
  if(img==NULL)   return;  
  SaveState();  
  pimg= cvCloneImage (img);  
  int typ;
  if(th.otsu)
    typ=th.type|CV_THRESH_OTSU;
  else
    typ=th.type;
  cvThreshold (img, pimg, th.thresh,th.maxVal,typ);



  proc->SetImage(pimg);
  After->redraw();

  char Buf[512];
  char *Types[]={"CV_THRESH_BINARY",
                 "CV_THRESH_BINARY_INV",
                 "CV_THRESH_TRUNC",
                 "CV_THRESH_TOZERO",
                 "CV_THRESH_TOZERO_INV"};

  Output->add("");
  Output->add("/* Normal Threshold of image */");
  Output->add("  if(pimg)");
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  pimg= cvCloneImage (img); ");
  char otsuOn[]= " | CV_THRESH_OTSU";
  char otsuOff[]= " ";
  char *p=th.otsu ? otsuOn : otsuOff;
  sprintf(Buf,"cvThreshold (img, pimg, %.f, %.f, %s%s);", th.thresh,th.maxVal,Types[th.type],p);
  Output->add(Buf);
  Output->bottomline(Output->size());
}

void Processor::AdaptiveThreshold() {
  if(img==NULL)   return;  


  if(img->nChannels==3){
    if(fl_choice("Source image must me single channel gray \n Do you want to convert it ?","No","Yes",NULL)==0)
      return; 
    RGBToGray();
    CopyTo1();
  }

  SaveState();  
  pimg= cvCloneImage (img);  
  int typ=th.type;
  if(typ>=1)
    typ=CV_THRESH_BINARY;
  cvAdaptiveThreshold( img, pimg,th.maxVal,th.method,typ,th.block_size,th.param1);


  proc->SetImage(pimg);
  After->redraw();

  char Buf[512];
  char *Types[]={"CV_THRESH_BINARY",
                 "CV_THRESH_BINARY_INV"};
  char *Methods[]={"CV_THRESH_BINARY",
                   "CV_THRESH_BINARY_INV"};                

  Output->add("");
  Output->add("/* Adaptive Threshold of image */");
  Output->add("  if(pimg)");
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  pimg= cvCloneImage (img); ");
  sprintf(Buf,"cvAdaptiveThreshold(img, pimg, %.f, %s , %s ,%d , %.f );",th.maxVal,Types[typ],Methods[th.method],th.block_size,th.param1);
  Output->add(Buf);
  Output->bottomline(Output->size());
}

void Processor::Erode() {
  if(img==NULL)   return;  

  SaveState();  
  IplConvKernel *element;
  pimg= cvCloneImage (img);  
  element = cvCreateStructuringElementEx (m.cols,m.rows,m.anchor_x,m.anchor_y,m.shape, NULL);
  cvErode (img,pimg, element,m.iterations);
  proc->SetImage(pimg);
  After->redraw();
  cvReleaseStructuringElement(&element );
  WriteCodeMorph(0);
}

void Processor::Dilate() {
  if(img==NULL)   return;  

  SaveState();  
  IplConvKernel *element;
  pimg= cvCloneImage (img);  
  element = cvCreateStructuringElementEx (m.cols,m.rows,m.anchor_x,m.anchor_y,m.shape, NULL);
  cvDilate (img,pimg, element,m.iterations);
  proc->SetImage(pimg);
  After->redraw();
  cvReleaseStructuringElement(&element );
  WriteCodeMorph(1);
}

void Processor::Open() {
  if(img==NULL)   return;  

  SaveState();  
  IplConvKernel *element;
  pimg= cvCloneImage (img);  
  timg= cvCloneImage (img);  
  element = cvCreateStructuringElementEx (m.cols,m.rows,m.anchor_x,m.anchor_y,m.shape, NULL);
  cvMorphologyEx (img, pimg, timg,element,CV_MOP_OPEN, m.iterations);
  proc->SetImage(pimg);
  After->redraw();
  cvReleaseStructuringElement(&element );
  cvReleaseImage (&timg);
  WriteCodeMorph(2);
}

void Processor::Close() {
  if(img==NULL)   return;  

  SaveState();  
  IplConvKernel *element;
  pimg= cvCloneImage (img);  
  timg= cvCloneImage (img);  
  element = cvCreateStructuringElementEx (m.cols,m.rows,m.anchor_x,m.anchor_y,m.shape, NULL);
  cvMorphologyEx (img, pimg, timg,element,CV_MOP_CLOSE, m.iterations);
  proc->SetImage(pimg);
  After->redraw();
  cvReleaseStructuringElement(&element );
  cvReleaseImage (&timg);
  WriteCodeMorph(3);
}

void Processor::Grad() {
  if(img==NULL)   return;  

  SaveState();  
  IplConvKernel *element;
  pimg= cvCloneImage (img);  
  timg= cvCloneImage (img);  
  element = cvCreateStructuringElementEx (m.cols,m.rows,m.anchor_x,m.anchor_y,m.shape, NULL);
  cvMorphologyEx (img, pimg, timg,element,CV_MOP_GRADIENT, m.iterations);
  proc->SetImage(pimg);
  After->redraw();
  cvReleaseStructuringElement(&element );
  cvReleaseImage (&timg);
  WriteCodeMorph(4);
}

void Processor::TopHat() {
  if(img==NULL)   return;  

  SaveState();  
  IplConvKernel *element;
  pimg= cvCloneImage (img);  
  timg= cvCloneImage (img);  
  element = cvCreateStructuringElementEx (m.cols,m.rows,m.anchor_x,m.anchor_y,m.shape, NULL);
  cvMorphologyEx (img, pimg, timg,element,CV_MOP_TOPHAT, m.iterations);
  proc->SetImage(pimg);
  After->redraw();
  cvReleaseStructuringElement(&element );
  cvReleaseImage (&timg);
  WriteCodeMorph(5);
}

void Processor::BlackHat() {
  if(img==NULL)   return;  

  SaveState();  
  IplConvKernel *element;
  pimg= cvCloneImage (img);  
  timg= cvCloneImage (img);  
  element = cvCreateStructuringElementEx (m.cols,m.rows,m.anchor_x,m.anchor_y,m.shape, NULL);
  cvMorphologyEx (img, pimg, timg,element,CV_MOP_BLACKHAT, m.iterations);
  proc->SetImage(pimg);
  After->redraw();
  cvReleaseStructuringElement(&element );
  cvReleaseImage (&timg);
  WriteCodeMorph(6);
}

void Processor::WriteCodeMorph(int i) {
  char Buf[512];
  char *Shapes[]={"CV_SHAPE_RECT",
                  "CV_SHAPE_CROSS",
                  "CV_SHAPE_ELLIPSE"};  
                
  char *Operations[]= {"Erode",
	               "Dilate",
		       "Open",
		       "Close",
		       "Gradiant",
		       "Top Hat",		     
		       "Black Hat"};                  
  char *OpCodes[]= {"CV_MOP_OPEN",
	            "CV_MOP_CLOSE",
		    "CV_MOP_GRADIENT",
		    "CV_MOP_TOPHAT",
		    "CV_MOP_BLACKHAT"};                  		     


  Output->add("");
  sprintf(Buf,"/* Aplly %s Morphological Operation */" ,Operations[i]);

  Output->add(Buf);
  Output->add("{");
  Output->add("  IplConvKernel *element;"); 
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  pimg= cvCloneImage (img); "); 
  sprintf(Buf,"  element = cvCreateStructuringElementEx (%d,%d,%d,%d,%s, NULL);",m.cols,m.rows,m.anchor_x,m.anchor_y,Shapes[m.shape]);
  Output->add(Buf);
  if(i>1){
    Output->add("  timg= cvCloneImage (img);"); 
    sprintf(Buf,"  cvMorphologyEx (img, pimg, timg,element,%s , %d);",OpCodes[i-2],m.iterations);
    Output->add(Buf);
    Output->add("  cvReleaseImage (&timg);");    
  }
  else if(i==0){
    sprintf(Buf,"  cvErode (img,pimg, element, %d);",m.iterations);
    Output->add(Buf);
  }else {
    sprintf(Buf,"  cvDilate (img,pimg, element, %d);",m.iterations);
    Output->add(Buf);
  }


  Output->add("  cvReleaseStructuringElement(&element );");
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::Sobel() {
  if(img==NULL)   return;  

  if(img->nChannels==3){
    if(fl_choice("Source image must me single channel gray \n Do you want to convert it ?","No","Yes",NULL)==0)
       return; 
    RGBToGray();
    CopyTo1();
  }

  SaveState();  
  timg = cvCreateImage (cvGetSize (img), IPL_DEPTH_16S, 1);  
  pimg = cvCreateImage (cvGetSize (img), IPL_DEPTH_8U, 1);  
  cvSobel (img, timg, ed.xOrder,ed.yOrder,Apertures[ed.aperture]);
  cvConvertScaleAbs (timg, pimg);
  proc->SetImage(pimg);
  After->redraw();

  cvReleaseImage (&timg);
// WriteCode

  char Buf[512];
  Output->add("");

  Output->add("/* Aplly Sobel Edge-Detection Operation */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  timg = cvCreateImage (cvGetSize (img), IPL_DEPTH_16S, 1);");  
  Output->add("  pimg = cvCreateImage (cvGetSize (img), IPL_DEPTH_8U, 1);");  
  sprintf(Buf,"  cvSobel (img, timg, %d, %d, %d);",ed.xOrder,ed.yOrder,Apertures[ed.aperture]);
  Output->add(Buf);
  Output->add("  cvConvertScaleAbs (timg, pimg);");
  Output->add("  cvReleaseImage (&timg);");
  Output->bottomline(Output->size());
}

void Processor::Laplace() {
  if(img==NULL)   return;  

  if(img->nChannels==3){
    if(fl_choice("Source image must me single channel gray \n Do you want to convert it ?","No","Yes",NULL)==0)
       return; 
    RGBToGray();
    CopyTo1();
  }

  SaveState();  
  timg = cvCreateImage (cvGetSize (img), IPL_DEPTH_16S, 1);  
  pimg = cvCreateImage (cvGetSize (img), IPL_DEPTH_8U, 1);  
  cvLaplace (img, timg,Apertures[ed.aperture]);
  cvConvertScaleAbs (timg, pimg);
  proc->SetImage(pimg);
  After->redraw();

  cvReleaseImage (&timg);
// WriteCode

  char Buf[512];
  Output->add("");

  Output->add("/* Aplly Laplace Edge-Detection Operation */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  timg = cvCreateImage (cvGetSize (img), IPL_DEPTH_16S, 1);");  
  Output->add("  pimg = cvCreateImage (cvGetSize (img), IPL_DEPTH_8U, 1);");  
  sprintf(Buf,"  cvLaplace (img, timg, %d);",Apertures[ed.aperture]);
  Output->add(Buf);
  Output->add("  cvConvertScaleAbs (timg, pimg);");
  Output->add("  cvReleaseImage (&timg);");
  Output->bottomline(Output->size());
}

void Processor::Canny() {
  if(img==NULL)   return;  

  if(img->nChannels==3){
    if(fl_choice("Source image must me single channel gray \n Do you want to convert it ?","No","Yes",NULL)==0)
      return; 
    RGBToGray();
    CopyTo1();
  }

  SaveState();  
  pimg = cvCreateImage (cvGetSize (img), IPL_DEPTH_8U, 1);  
  // Dikkat min aperture size for canny 3
  cvCanny (img, pimg, ed.tmin,ed.tmax,Apertures[ed.aperture]<3 ? 3 : Apertures[ed.aperture]);  
  proc->SetImage(pimg);
  After->redraw();


  // WriteCode
  char Buf[512];
  Output->add("");

  Output->add("/* Aplly Canny Edge-Detection Operation */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  pimg = cvCreateImage (cvGetSize (img), IPL_DEPTH_8U, 1);");  
  sprintf(Buf,"  cvCanny (img, pimg, %d, %d, %d);",(int)ed.tmin,(int)ed.tmax,(Apertures[ed.aperture]<3 ? 3 : Apertures[ed.aperture]));
  Output->add(Buf);
  Output->bottomline(Output->size());
}

void Processor::Add() {
  if(img==NULL)   return;  
  if(pimg==NULL)  return;  
  if(!((img->nChannels==pimg->nChannels)&& (img->width==pimg->width) &&(img->height==pimg->height)) ){
     fl_alert("All the arrays must have the same type,and the same size ");
     return;        
  }


  SaveState();  
  IplImage *mask=NULL;

  if(mimg && (mimg->width==pimg->width) &&(mimg->height==pimg->height))  
    if(mimg->nChannels==1){
      if(fl_choice("Do you want to use Memory Image as an Mask ?","No","Yes",NULL))
        mask=mimg;
    }

  timg= cvCloneImage (img);  

  cvAdd(img, pimg, timg, mask);

  proc->SetImage(timg);
  pimg=timg;
  After->redraw();

// WriteCode

  Output->add("");

  Output->add("/* Aplly Adding Operation */");
  Output->add("/* Alert! there is no size and channel check */");
  Output->add("{");
  Output->add("  IplImage *mask=NULL;");
  if(mimg){
    Output->add("  if(mimg->nChannels==1)");
    Output->add("    mask=mimg;");
  }

  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  timg = cvCloneImage (img);");  
  Output->add("  cvAdd(img, pimg, timg, mask);");
  Output->add("  cvReleaseImage (&pimg);");
  Output->add("  pimg=timg;");
  Output->add("}");


  Output->bottomline(Output->size());
}

void Processor::Sub() {
  if(img==NULL)   return;  
  if(pimg==NULL)  return;  
  if(!((img->nChannels==pimg->nChannels)&& (img->width==pimg->width) &&(img->height==pimg->height)) ){
     fl_alert("All the arrays must have the same type,and the same size ");
     return;        
  }

  SaveState();  
  IplImage *mask=NULL;
  if(mimg && (mimg->width==pimg->width) &&(mimg->height==pimg->height))  
    if(mimg->nChannels==1){
      if(fl_choice("Do you want to use Memory Image as an Mask ?","No","Yes",NULL))
        mask=mimg;
    }

  timg= cvCloneImage (img);  

  cvSub(img, pimg, timg, mask);

  proc->SetImage(timg);
  pimg=timg;
  After->redraw();

// WriteCode

  Output->add("");
  Output->add("/* Aplly Subtraction Operation */");
  Output->add("/* Alert! there is no size and channel check */");
  Output->add("{");
  Output->add("  IplImage *mask=NULL;");
  if(mimg){
    Output->add("  if(mimg->nChannels==1)");
    Output->add("    mask=mimg;");
  }
  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  timg = cvCloneImage (img);");  
  Output->add("  cvSub(img, pimg, timg, mask);");
  Output->add("  cvReleaseImage (&pimg);");
  Output->add("  pimg=timg;");
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::Mul() {
  if(img==NULL)   return;  
  if(pimg==NULL)  return;  
  if(!((img->nChannels==pimg->nChannels)&& (img->width==pimg->width) &&(img->height==pimg->height)) ){
     fl_alert("All the arrays must have the same type,and the same size ");
     return;       
  }

  SaveState();  
  timg= cvCloneImage (img);  
  cvMul(img, pimg, timg);

  proc->SetImage(timg);
  pimg=timg;
  After->redraw();

// WriteCode

  Output->add("");
  Output->add("/* Aplly Multiplication Operation */");
  Output->add("/* Alert! there is no size and channel check */");
  Output->add("{");
  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  timg = cvCloneImage (img);");  
  Output->add("  cvMul(img, pimg, timg, 1);");
  Output->add("  cvReleaseImage (&pimg);");
  Output->add("  pimg=timg;");
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::Div() {
  if(img==NULL)   return;  
  if(pimg==NULL)  return;  
  if(!((img->nChannels==pimg->nChannels)&& (img->width==pimg->width) &&(img->height==pimg->height)) ){
     fl_alert("All the arrays must have the same type,and the same size ");
     return;       
  }


  SaveState();  
  timg= cvCloneImage (img);  
  cvDiv(img, pimg, timg);

  proc->SetImage(timg);
  pimg=timg;
  After->redraw();

// WriteCode

  Output->add("");
  Output->add("/* Aplly Division Operation */");
  Output->add("/* Alert! there is no size and channel check */");
  Output->add("{");
  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  timg = cvCloneImage (img);");  
  Output->add("  cvDiv(img, pimg, timg, 1);");
  Output->add("  cvReleaseImage (&pimg);");
  Output->add("  pimg=timg;");
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::Max() {
  if(img==NULL)   return;  
  if(pimg==NULL)  return;  
  if(!(((pimg->nChannels==1)&&(img->nChannels==1)&&img->nChannels==pimg->nChannels)&& (img->width==pimg->width) &&(img->height==pimg->height)) ){
     fl_alert("All the arrays must have a single channel, the same data type and the same size ");
     return;        
  }


  SaveState();  
  timg= cvCloneImage (img);  
  cvMax(img, pimg, timg);

  proc->SetImage(timg);
  pimg=timg;
  After->redraw();

// WriteCode

  Output->add("");
  Output->add("/* Aplly Max Operation */");
  Output->add("/* Alert! there is no size and channel check */");
  Output->add("{");
  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  timg = cvCloneImage (img);");  
  Output->add("  cvMax(img, pimg, timg);");
  Output->add("  cvReleaseImage (&pimg);");
  Output->add("  pimg=timg;");
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::Min() {
  if(img==NULL)   return;  
  if(pimg==NULL)  return;  
  if(!(((pimg->nChannels==1)&&(img->nChannels==1)&&img->nChannels==pimg->nChannels)&& (img->width==pimg->width) &&(img->height==pimg->height)) ){
     fl_alert("All the arrays must have a single channel, the same data type and the same size ");
     return;       
  }


  SaveState();  
  timg= cvCloneImage (img);  
  cvMin(img, pimg, timg);

  proc->SetImage(timg);
  pimg=timg;
  After->redraw();

// WriteCode

  Output->add("");
  Output->add("/* Aplly Min Operation */");
  Output->add("/* Alert! there is no size and channel check */");
  Output->add("{");
  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  timg = cvCloneImage (img);");  
  Output->add("  cvMin(img, pimg, timg);");
  Output->add("  cvReleaseImage (&pimg);");
  Output->add("  pimg=timg;");
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::AbsDiff() {
  if(img==NULL)   return;  
  if(pimg==NULL)  return;  
  if(!((img->nChannels==pimg->nChannels)&& (img->width==pimg->width) &&(img->height==pimg->height)) ){
     fl_alert("All the arrays must have the same type,and the same size ");
     return;        
  }

  SaveState();  
  timg= cvCloneImage (img);  
  cvAbsDiff(img, pimg, timg);

  proc->SetImage(timg);
  pimg=timg;
  After->redraw();

// WriteCode

  Output->add("");
  Output->add("/* Aplly Absolute Difference  Operation */");
  Output->add("/* Alert! there is no size and channel check */");
  Output->add("{");
  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  timg = cvCloneImage (img);");  
  Output->add("  cvAbsDiff(img, pimg, timg);");
  Output->add("  cvReleaseImage (&pimg);");
  Output->add("  pimg=timg;");
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::Compare(int op) {
  if(img==NULL)   return;  
  if(pimg==NULL)  return;  
  if(!(((pimg->nChannels==1)&&(img->nChannels==1)&&img->nChannels==pimg->nChannels)&& (img->width==pimg->width) &&(img->height==pimg->height)) ){
     fl_alert("All the arrays must have a single channel, the same data type and the same size ");
     return;        
  }

  SaveState();  

  timg= cvCloneImage (img);  
  cvCmp(img,pimg,timg,op);

  proc->SetImage(timg);
  pimg=timg;
  After->redraw();

// WriteCode

  char Buf[512];
  char *OpCodes[]= {"CV_CMP_EQ",
	            "CV_CMP_GT",
		    "CV_CMP_GE",
		    "CV_CMP_LT",
		    "CV_CMP_LE",		    
		    "CV_CMP_NE"}; 

  Output->add("");
  Output->add("/* Aplly Compare Operation */");
  Output->add("/* Alert! there is no size and channel check */");
  Output->add("{");
  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  timg = cvCloneImage (img);");  
  sprintf(Buf,"  cvCmp(img, pimg, timg, %s );",OpCodes[op]);
  Output->add(Buf);
  Output->add("  cvReleaseImage (&pimg);");
  Output->add("  pimg=timg;");
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::And() {
  if(img==NULL)   return;  
  if(pimg==NULL)  return;  
  if(!((img->nChannels==pimg->nChannels)&& (img->width==pimg->width) &&(img->height==pimg->height)) ){
     fl_alert("All the arrays must have the same type,and the same size ");
     return;     
  }


  SaveState();  
  IplImage *mask=NULL;
  if(mimg && (mimg->width==pimg->width) &&(mimg->height==pimg->height))  
    if(mimg->nChannels==1){
      if(fl_choice("Do you want to use Memory Image as an Mask ?","No","Yes",NULL))
        mask=mimg;
    }

  timg= cvCloneImage (img);  
  cvAnd(img, pimg, timg, mask);

  proc->SetImage(timg);
  pimg=timg;
  After->redraw();

// WriteCode

  Output->add("");
  Output->add("/* Aplly And Operation */");
  Output->add("/* Alert! there is no size and channel check */");
  Output->add("{");
  Output->add("  IplImage *mask=NULL;");
  if(mimg){
    Output->add("  if(mimg->nChannels==1)");
    Output->add("    mask=mimg;");
  }
  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  timg = cvCloneImage (img);");  
  Output->add("  cvAnd(img, pimg, timg, mask);");
  Output->add("  cvReleaseImage (&pimg);");
  Output->add("  pimg=timg;");
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::Or() {
  if(img==NULL)   return;  
  if(pimg==NULL)  return;  
  if(!((img->nChannels==pimg->nChannels)&& (img->width==pimg->width) &&(img->height==pimg->height)) ){
     fl_alert("All the arrays must have the same type,and the same size ");
     return;        
  }


  SaveState();  
  IplImage *mask=NULL;
  if(mimg && (mimg->width==pimg->width) &&(mimg->height==pimg->height))  
    if(mimg->nChannels==1){
      if(fl_choice("Do you want to use Memory Image as an Mask ?","No","Yes",NULL))
        mask=mimg;
    }

  timg= cvCloneImage (img);  
  cvOr(img, pimg, timg, mask);

  proc->SetImage(timg);
  pimg=timg;
  After->redraw();

// WriteCode

  Output->add("");
  Output->add("/* Aplly Or Operation */");
  Output->add("/* Alert! there is no size and channel check */");
  Output->add("{");
  Output->add("  IplImage *mask=NULL;");
  if(mimg){
    Output->add("  if(mimg->nChannels==1)");
    Output->add("    mask=mimg;");
  }
  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  timg = cvCloneImage (img);");  
  Output->add("  cvOr(img, pimg, timg, mask);");
  Output->add("  cvReleaseImage (&pimg);");
  Output->add("  pimg=timg;");
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::Xor() {
  if(img==NULL)   return;  
  if(pimg==NULL)  return;  
  if(!((img->nChannels==pimg->nChannels)&& (img->width==pimg->width) &&(img->height==pimg->height)) ){
     fl_alert("All the arrays must have the same type,and the same size ");
     return;       
  }


  SaveState();  
  IplImage *mask=NULL;
  if(mimg && (mimg->width==pimg->width) &&(mimg->height==pimg->height))  
    if(mimg->nChannels==1){
      if(fl_choice("Do you want to use Memory Image as an Mask ?","No","Yes",NULL))
        mask=mimg;
    }

  timg= cvCloneImage (img);  
  cvXor(img, pimg, timg, mask);

  proc->SetImage(timg);
  pimg=timg;
  After->redraw();

// WriteCode

  Output->add("");
  Output->add("/* Aplly Xor Operation */");
  Output->add("/* Alert! there is no size and channel check */");
  Output->add("{");
  Output->add("  IplImage *mask=NULL;");
  if(mimg){
    Output->add("  if(mimg->nChannels==1)");
    Output->add("    mask=mimg;");
  }
  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  timg = cvCloneImage (img);");  
  Output->add("  cvXor(img, pimg, timg, mask);");
  Output->add("  cvReleaseImage (&pimg);");
  Output->add("  pimg=timg;");
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::Not() {
  if(img==NULL)   return;  
  

  SaveState();  
  pimg= cvCloneImage (img);  
  cvNot(img, pimg);

  proc->SetImage(pimg);
  After->redraw();

// WriteCode

  Output->add("");
  Output->add("/* Aplly Logical Not Operation */");
  Output->add("/* Alert! there is no size and channel check */");
  Output->add("{");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  pimg = cvCloneImage (img);");  
  Output->add("  cvNot(img, pimg);");
  Output->add("}");
  Output->bottomline(Output->size());
}

void cb_Ok(Fl_Return_Button*o, void*w) {
  ((Fl_Window *)(o->parent()))->hide();
}

AboutDlg::AboutDlg() {
  { Fl_Double_Window* o = window = new Fl_Double_Window(441, 284, "About");
    window->color((Fl_Color)31);
    window->user_data((void*)(this));
    window->align(FL_ALIGN_CENTER);
    { Ok = new Fl_Return_Button(300, 240, 130, 30, "Ok");
      Ok->box(FL_GTK_THIN_UP_BOX);
      Ok->color((Fl_Color)21);
      Ok->callback((Fl_Callback*)cb_Ok);
    } // Fl_Return_Button* Ok
    { Info = new Fl_Browser(15, 14, 415, 212);
      Info->box(FL_EMBOSSED_FRAME);
      Info->color((Fl_Color)31);
      Info->textcolor(4);
    } // Fl_Browser* Info
    o->set_modal();
    window->end();
  } // Fl_Double_Window* window
}

void AboutDlg::show() {
  Info->add("@l@c@C1cvPreProcessor");
  Info->add("  cvPreProcessor is a GUI tool for OpenCv ");
  Info->add("  Version : 0.8 ");
  Info->add(" ");
  Info->add("* Programmed by BlueKid");
  Info->add("  http://derindelimavi.blogspot.com/");
  Info->add(" ");
  Info->add("* Please Send me any suggestion, modification or bugs.");
  Info->add(" Don't hesitate to contact me for any question");
  Info->add(" I will be very grateful with your feedbacks.");
  Info->add(" bluekid70@gmail.com");

  window->show();
}

void AboutDlg::hide() {
  window->hide();
}

void MorphOptions::cb_Ok_i(Fl_Return_Button*, void*) {
  p->m.iterations=iterations->value();
p->m.cols=cols->value();
p->m.rows=rows->value();
p->m.anchor_x=ax->value();
p->m.anchor_y=ay->value();
p->m.shape=Shape->value();
hide();
}
void MorphOptions::cb_Ok(Fl_Return_Button* o, void* v) {
  ((MorphOptions*)(o->parent()->user_data()))->cb_Ok_i(o,v);
}

MorphOptions::MorphOptions() {
  { Fl_Double_Window* o = window = new Fl_Double_Window(271, 336, "Morphological Operations");
    window->color((Fl_Color)31);
    window->user_data((void*)(this));
    window->align(FL_ALIGN_CENTER);
    { Ok = new Fl_Return_Button(131, 296, 130, 30, "Ok");
      Ok->box(FL_GTK_THIN_UP_BOX);
      Ok->color((Fl_Color)21);
      Ok->callback((Fl_Callback*)cb_Ok);
    } // Fl_Return_Button* Ok
    { iterations = new Fl_Spinner(150, 16, 40, 24, "Number of iterations:");
      iterations->maximum(10);
      iterations->value(1);
    } // Fl_Spinner* iterations
    { Fl_Group* o = new Fl_Group(10, 63, 245, 209, "Structuring Element");
      o->box(FL_ENGRAVED_FRAME);
      o->align(FL_ALIGN_TOP_LEFT);
      { Shape = new Fl_Choice(80, 80, 155, 24, "Shape :");
        Shape->box(FL_NO_BOX);
        Shape->down_box(FL_BORDER_BOX);
        Shape->add("Rectangular ");
        Shape->add("Cross-Shaped ");
        Shape->add("Elliptic");
      } // Fl_Choice* Shape
      { cols = new Fl_Spinner(195, 114, 40, 24, "Number of columns :");
        cols->maximum(33);
        cols->value(1);
      } // Fl_Spinner* cols
      { rows = new Fl_Spinner(195, 154, 40, 24, "Number of rows :");
        rows->maximum(33);
        rows->value(1);
      } // Fl_Spinner* rows
      { ax = new Fl_Spinner(195, 188, 40, 24, "Anchor X :");
        ax->maximum(16);
        ax->value(1);
      } // Fl_Spinner* ax
      { ay = new Fl_Spinner(195, 222, 40, 24, "Anchor Y :");
        ay->maximum(16);
        ay->value(1);
      } // Fl_Spinner* ay
      o->end();
    } // Fl_Group* o
    o->set_modal();
    window->end();
  } // Fl_Double_Window* window
}

void MorphOptions::show() {
  iterations->value(p->m.iterations);
  cols->value(p->m.cols);
  rows->value(p->m.rows);
  ax->value(p->m.anchor_x);
  ay->value(p->m.anchor_y);
  Shape->value(p->m.shape);
  window->show();
}

void MorphOptions::hide() {
  window->hide();
}

void EdgeOptions::cb_Ok1_i(Fl_Return_Button*, void*) {
  p->ed.xOrder=xOrder->value();
p->ed.yOrder=yOrder->value();
p->ed.tmin=tmin->value();
p->ed.tmax=tmax->value();
p->ed.aperture=Aperture->value();

hide();
}
void EdgeOptions::cb_Ok1(Fl_Return_Button* o, void* v) {
  ((EdgeOptions*)(o->parent()->user_data()))->cb_Ok1_i(o,v);
}

void EdgeOptions::cb_tmin_i(Fl_Value_Slider*, void*) {
  tmax->minimum(tmin->value()+1);
tmax->redraw();
}
void EdgeOptions::cb_tmin(Fl_Value_Slider* o, void* v) {
  ((EdgeOptions*)(o->parent()->parent()->user_data()))->cb_tmin_i(o,v);
}

void EdgeOptions::cb_tmax_i(Fl_Value_Slider*, void*) {
  tmin->maximum(tmax->value()-1);
tmin->redraw();
}
void EdgeOptions::cb_tmax(Fl_Value_Slider* o, void* v) {
  ((EdgeOptions*)(o->parent()->parent()->user_data()))->cb_tmax_i(o,v);
}

EdgeOptions::EdgeOptions() {
  { Fl_Double_Window* o = window = new Fl_Double_Window(271, 336, "Edge Detection ");
    window->color((Fl_Color)31);
    window->user_data((void*)(this));
    window->align(FL_ALIGN_CENTER);
    { Ok = new Fl_Return_Button(131, 296, 130, 30, "Ok");
      Ok->box(FL_GTK_UP_BOX);
      Ok->color((Fl_Color)21);
      Ok->callback((Fl_Callback*)cb_Ok1);
    } // Fl_Return_Button* Ok
    { Aperture = new Fl_Choice(111, 16, 155, 24, "Aperture  Size :");
      Aperture->down_box(FL_BORDER_BOX);
      Aperture->add("CV_SCHARR");
      Aperture->add("1x3 or 3x1");
      Aperture->add("3x3");Aperture->add("5x5");
      Aperture->add("7x7");Aperture->value(1);
    } // Fl_Choice* Aperture
    { Fl_Group* o = new Fl_Group(15, 66, 246, 60, "Sobel");
      o->box(FL_EMBOSSED_FRAME);
      o->labelfont(2);
      o->labelcolor((Fl_Color)4);
      o->align(FL_ALIGN_TOP_LEFT);
      { xOrder = new Fl_Round_Button(29, 75, 81, 15, "X Order");
        xOrder->type(102);
        xOrder->down_box(FL_ROUND_DOWN_BOX);
        xOrder->value(1);
        xOrder->align(FL_ALIGN_RIGHT|FL_ALIGN_INSIDE);
      } // Fl_Round_Button* xOrder
      { yOrder = new Fl_Round_Button(31, 100, 79, 16, "YOrder");
        yOrder->type(102);
        yOrder->down_box(FL_ROUND_DOWN_BOX);
        yOrder->align(FL_ALIGN_RIGHT|FL_ALIGN_INSIDE);
      } // Fl_Round_Button* yOrder
      o->end();
    } // Fl_Group* o
    { Fl_Group* o = new Fl_Group(15, 146, 246, 129, "Canny");
      o->box(FL_EMBOSSED_FRAME);
      o->labelfont(2);
      o->labelcolor((Fl_Color)4);
      o->align(FL_ALIGN_TOP_LEFT);
      { tmin = new Fl_Value_Slider(25, 175, 226, 20, "Threshold Min");
        tmin->type(5);
        tmin->box(FL_PLASTIC_DOWN_BOX);
        tmin->color((Fl_Color)12);
        tmin->selection_color((Fl_Color)1);
        tmin->maximum(255);
        tmin->step(1);
        tmin->textsize(14);
        tmin->callback((Fl_Callback*)cb_tmin);
        tmin->align(FL_ALIGN_TOP_LEFT);
      } // Fl_Value_Slider* tmin
      { tmax = new Fl_Value_Slider(25, 230, 226, 20, "Threshold Max");
        tmax->type(5);
        tmax->box(FL_PLASTIC_DOWN_BOX);
        tmax->color((Fl_Color)12);
        tmax->selection_color((Fl_Color)1);
        tmax->maximum(255);
        tmax->step(1);
        tmax->value(255);
        tmax->textsize(14);
        tmax->callback((Fl_Callback*)cb_tmax);
        tmax->align(FL_ALIGN_TOP_LEFT);
      } // Fl_Value_Slider* tmax
      o->end();
    } // Fl_Group* o
    o->set_modal();
    window->end();
  } // Fl_Double_Window* window
}

void EdgeOptions::show() {
  xOrder->value(p->ed.xOrder);
  yOrder->value(p->ed.yOrder);
  tmin->value(p->ed.tmin);
  tmax->value(p->ed.tmax);
  Aperture->value(p->ed.aperture);

  window->show();
}

void EdgeOptions::hide() {
  window->hide();
}

void ThresholdOptions::cb_Ok2_i(Fl_Return_Button*, void*) {
  Update();
hide();
}
void ThresholdOptions::cb_Ok2(Fl_Return_Button* o, void* v) {
  ((ThresholdOptions*)(o->parent()->user_data()))->cb_Ok2_i(o,v);
}

void ThresholdOptions::cb_Otsu_i(Fl_Check_Button*, void*) {
  if(Otsu->value()) 
  thresh->deactivate();
else
  thresh->activate();
}
void ThresholdOptions::cb_Otsu(Fl_Check_Button* o, void* v) {
  ((ThresholdOptions*)(o->parent()->parent()->user_data()))->cb_Otsu_i(o,v);
}

void ThresholdOptions::cb_Apply_i(Fl_Button*, void*) {
  Update();
p->NormalThreshold();
}
void ThresholdOptions::cb_Apply(Fl_Button* o, void* v) {
  ((ThresholdOptions*)(o->parent()->user_data()))->cb_Apply_i(o,v);
}

void ThresholdOptions::cb_Apply1_i(Fl_Button*, void*) {
  Update();
p->AdaptiveThreshold();
}
void ThresholdOptions::cb_Apply1(Fl_Button* o, void* v) {
  ((ThresholdOptions*)(o->parent()->user_data()))->cb_Apply1_i(o,v);
}

ThresholdOptions::ThresholdOptions() {
  { Fl_Double_Window* o = window = new Fl_Double_Window(416, 448, "Threshold Options");
    window->color((Fl_Color)31);
    window->user_data((void*)(this));
    window->align(FL_ALIGN_CENTER);
    { Ok = new Fl_Return_Button(306, 405, 99, 30, "Ok");
      Ok->box(FL_GTK_THIN_UP_BOX);
      Ok->color((Fl_Color)21);
      Ok->callback((Fl_Callback*)cb_Ok2);
    } // Fl_Return_Button* Ok
    { Fl_Group* o = new Fl_Group(15, 116, 390, 112, "Normal ");
      o->box(FL_EMBOSSED_FRAME);
      o->labelfont(2);
      o->labelcolor((Fl_Color)4);
      o->align(FL_ALIGN_TOP_LEFT);
      { thresh = new Fl_Value_Slider(25, 145, 370, 20, "Threshold Value");
        thresh->type(5);
        thresh->box(FL_PLASTIC_DOWN_BOX);
        thresh->color((Fl_Color)12);
        thresh->selection_color((Fl_Color)1);
        thresh->maximum(255);
        thresh->step(1);
        thresh->value(128);
        thresh->textsize(14);
        thresh->align(FL_ALIGN_TOP_LEFT);
      } // Fl_Value_Slider* thresh
      { Otsu = new Fl_Check_Button(30, 190, 64, 20, "use Otsu method");
        Otsu->down_box(FL_DOWN_BOX);
        Otsu->callback((Fl_Callback*)cb_Otsu);
      } // Fl_Check_Button* Otsu
      o->end();
    } // Fl_Group* o
    { max = new Fl_Value_Slider(20, 30, 380, 20, "Max Value");
      max->type(5);
      max->box(FL_PLASTIC_DOWN_BOX);
      max->color((Fl_Color)12);
      max->selection_color((Fl_Color)1);
      max->maximum(255);
      max->step(1);
      max->value(255);
      max->textsize(14);
      max->align(FL_ALIGN_TOP_LEFT);
    } // Fl_Value_Slider* max
    { Type = new Fl_Choice(130, 66, 245, 24, "Threshold Type :");
      Type->down_box(FL_BORDER_BOX);
      Type->add("CV_THRESH_BINARY");
      Type->add("CV_THRESH_BINARY_INV");
      Type->add("CV_THRESH_TRUNC");Type->add("CV_THRESH_TOZERO");
      Type->add("CV_THRESH_TOZERO_INV");Type->value(0);
    } // Fl_Choice* Type
    { Fl_Group* o = new Fl_Group(20, 254, 385, 133, "Adaptive Threshold");
      o->box(FL_EMBOSSED_FRAME);
      o->labelfont(2);
      o->labelcolor((Fl_Color)4);
      o->align(FL_ALIGN_TOP_LEFT);
      { Method = new Fl_Choice(89, 260, 306, 21, "Method :");
        Method->down_box(FL_BORDER_BOX);
        Method->add("CV_ADAPTIVE_THRESH_MEAN_C");
        Method->add("CV_ADAPTIVE_THRESH_GAUSSIAN_C");
        Method->value(0);
      } // Fl_Choice* Method
      { BlockSize = new Fl_Spinner(110, 339, 40, 24, "Block Size :");
        BlockSize->minimum(3);
        BlockSize->maximum(33);
        BlockSize->step(2);
        BlockSize->value(3);
      } // Fl_Spinner* BlockSize
      { Param1 = new Fl_Value_Input(155, 296, 40, 24, "Method-parameter:");
        Param1->minimum(-50);
        Param1->maximum(50);
        Param1->value(5);
      } // Fl_Value_Input* Param1
      o->end();
    } // Fl_Group* o
    { Fl_Button* o = new Fl_Button(20, 405, 105, 30, "Apply Normal ");
      o->box(FL_PLASTIC_UP_BOX);
      o->color((Fl_Color)1);
      o->callback((Fl_Callback*)cb_Apply);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(135, 405, 105, 30, "Apply Adaptive");
      o->box(FL_PLASTIC_UP_BOX);
      o->color((Fl_Color)1);
      o->callback((Fl_Callback*)cb_Apply1);
    } // Fl_Button* o
    o->set_modal();
    window->end();
  } // Fl_Double_Window* window
}

void ThresholdOptions::show() {
  thresh->value(p->th.thresh);
  max->value(p->th.maxVal);
  Type->value(p->th.type);
  Method->value(p->th.method);
  BlockSize->value(p->th.block_size);
  Param1->value(p->th.param1);
  Otsu->value(p->th.otsu);
  if(Otsu->value()) 
    thresh->deactivate();
  else
    thresh->activate();


  window->show();
}

void ThresholdOptions::hide() {
  window->hide();
}

void ThresholdOptions::Update() {
  p->th.thresh=thresh->value();
  p->th.maxVal=max->value();
  p->th.type=Type->value();
  p->th.method=Method->value();
  p->th.block_size=BlockSize->value();
  p->th.param1=Param1->value();
  p->th.otsu=Otsu->value();
}

void ReSizeForm::cb_Ok3_i(Fl_Return_Button*, void*) {
  p->r.method=Interpolation->value();
  p->r.ratio=ratio->value();
  p->r.aspect=aspect->value();
  p->r.rwidth=rwidth->value();
  p->r.rheight=rheight->value();  
  p->ReSize();
  hide();
}
void ReSizeForm::cb_Ok3(Fl_Return_Button* o, void* v) {
  ((ReSizeForm*)(o->parent()->user_data()))->cb_Ok3_i(o,v);
}

void ReSizeForm::cb_aspect_i(Fl_Check_Button*, void*) {
  if(aspect->value())
  ratio->activate();
else
  ratio->deactivate();
}
void ReSizeForm::cb_aspect(Fl_Check_Button* o, void* v) {
  ((ReSizeForm*)(o->parent()->user_data()))->cb_aspect_i(o,v);
}

void ReSizeForm::cb_ratio_i(Fl_Value_Slider*, void*) {
  rwidth->value(int(oldw->value()*ratio->value()*0.01));
rheight->value(int(oldh->value()*ratio->value()*0.01));
}
void ReSizeForm::cb_ratio(Fl_Value_Slider* o, void* v) {
  ((ReSizeForm*)(o->parent()->user_data()))->cb_ratio_i(o,v);
}

ReSizeForm::ReSizeForm() {
  { Fl_Double_Window* o = window = new Fl_Double_Window(359, 336, "ReSize Image");
    window->color((Fl_Color)31);
    window->user_data((void*)(this));
    window->align(FL_ALIGN_CENTER);
    { Ok = new Fl_Return_Button(215, 296, 130, 30, "Ok");
      Ok->box(FL_GTK_THIN_UP_BOX);
      Ok->color((Fl_Color)21);
      Ok->callback((Fl_Callback*)cb_Ok3);
    } // Fl_Return_Button* Ok
    { Interpolation = new Fl_Choice(115, 21, 195, 24, "Interpolation :");
      Interpolation->box(FL_NO_BOX);
      Interpolation->down_box(FL_BORDER_BOX);
      Interpolation->add("Nearest-Neigbor");
      Interpolation->add("Bilinear");
      Interpolation->add("Pixel Area");
      Interpolation->add("Bicubic");Interpolation->value(1);
    } // Fl_Choice* Interpolation
    { aspect = new Fl_Check_Button(30, 134, 210, 26, "Preserve Aspect Ratio");
      aspect->down_box(FL_DOWN_BOX);
      aspect->value(1);
      aspect->callback((Fl_Callback*)cb_aspect);
    } // Fl_Check_Button* aspect
    { oldw = new Fl_Value_Output(120, 66, 120, 24, "Image Width:");
      oldw->value(10);
    } // Fl_Value_Output* oldw
    { oldh = new Fl_Value_Output(120, 100, 120, 24, "Image Height:");
      oldh->value(20);
    } // Fl_Value_Output* oldh
    { ratio = new Fl_Value_Slider(89, 170, 251, 20, "Ratio % :");
      ratio->type(1);
      ratio->color((Fl_Color)23);
      ratio->minimum(10);
      ratio->maximum(500);
      ratio->step(10);
      ratio->value(100);
      ratio->textsize(14);
      ratio->callback((Fl_Callback*)cb_ratio);
      ratio->align(FL_ALIGN_LEFT);
    } // Fl_Value_Slider* ratio
    { rwidth = new Fl_Value_Input(120, 206, 147, 24, "New Width:");
    } // Fl_Value_Input* rwidth
    { rheight = new Fl_Value_Input(120, 246, 147, 24, "New Heigth:");
    } // Fl_Value_Input* rheight
    o->set_modal();
    window->end();
  } // Fl_Double_Window* window
}

void ReSizeForm::show() {
  oldw->value(img->width);
  oldh->value(img->height);
  Interpolation->value(p->r.method);
  ratio->value(p->r.ratio);
  aspect->value(p->r.aspect);

  if(aspect->value()){
    ratio->activate();
    rwidth->value(int(oldw->value()*ratio->value()*0.01));
    rheight->value(int(oldh->value()*ratio->value()*0.01));  
  }
  else{
    ratio->deactivate();
    rwidth->value(img->width);
    rheight->value(img->height);  
  }
  
  window->show();
}

void ReSizeForm::hide() {
  window->hide();
}

void HistForm::cb_Ok4_i(Fl_Return_Button*, void*) {
  hide();
}
void HistForm::cb_Ok4(Fl_Return_Button* o, void* v) {
  ((HistForm*)(o->parent()->user_data()))->cb_Ok4_i(o,v);
}

void HistForm::cb_Type_i(Fl_Spinner*, void*) {
  Chart->type(Type->value());
Chart->redraw();
}
void HistForm::cb_Type(Fl_Spinner* o, void* v) {
  ((HistForm*)(o->parent()->user_data()))->cb_Type_i(o,v);
}

void HistForm::cb_Ch_i(Fl_Choice*, void*) {
  Draw();
}
void HistForm::cb_Ch(Fl_Choice* o, void* v) {
  ((HistForm*)(o->parent()->user_data()))->cb_Ch_i(o,v);
}

HistForm::HistForm() {
  { Fl_Double_Window* o = window = new Fl_Double_Window(811, 456, "Color Histogram");
    window->color((Fl_Color)31);
    window->user_data((void*)(this));
    window->align(FL_ALIGN_CENTER);
    { Ok = new Fl_Return_Button(671, 416, 130, 30, "Ok");
      Ok->box(FL_GTK_THIN_UP_BOX);
      Ok->color((Fl_Color)21);
      Ok->callback((Fl_Callback*)cb_Ok4);
    } // Fl_Return_Button* Ok
    { Chart = new Fl_Chart(10, 44, 791, 362);
      Chart->box(FL_GTK_DOWN_BOX);
      Chart->color((Fl_Color)18);
      Chart->selection_color(FL_BACKGROUND_COLOR);
      Chart->labeltype(FL_NORMAL_LABEL);
      Chart->labelfont(0);
      Chart->labelsize(14);
      Chart->labelcolor(FL_FOREGROUND_COLOR);
      Chart->align(FL_ALIGN_CENTER);
      Chart->when(FL_WHEN_RELEASE);
    } // Fl_Chart* Chart
    { Type = new Fl_Spinner(100, 10, 40, 24, "Chart Type  :");
      Type->minimum(0);
      Type->maximum(4);
      Type->value(3);
      Type->callback((Fl_Callback*)cb_Type);
    } // Fl_Spinner* Type
    { Ch = new Fl_Choice(260, 10, 190, 24, "Channel :");
      Ch->down_box(FL_BORDER_BOX);
      Ch->callback((Fl_Callback*)cb_Ch);
      Ch->add("Red"); Ch->add("Green");Ch->add("Blue");
      Ch->add("Hue");Ch->add("Saturation");
      Ch->value(0);
    } // Fl_Choice* Ch
    o->set_modal();
    window->end();
  } // Fl_Double_Window* window
}

void HistForm::show() {
  Chart->autosize(1);
Calculate();
Draw();
if(img->nChannels==1)
  Ch->hide();

window->show();
}

void HistForm::hide() {
  int k=1;
  if(img->nChannels==3) 
    k=5;
  for(int i=0;i< k;i++){
    cvReleaseImage (&himg[i]);  
    cvReleaseHist (&hist[i]);  
  }  
//  fl_alert("Images Released");
  window->hide();
}

void HistForm::Draw() {
  int np=256;
int kRed[]  ={1,0,0,0,1,1};
int kGreen[]={0,1,0,1,1,1};
int kBlue[]={0,0,1,1,0,1};
int j=Ch->value();
int ci;

if(img->nChannels==1)
  ci=5;
else
  ci=j;

Chart->clear();
Chart->type(Type->value());
if(j==3)
  np=181;

char buf[4];
for(int i=0;i<np;i++){

  if(i%15==0){
     sprintf(buf,"%03d",i);
  }
  else
    buf[0]=0;
  Chart->add(cvGetReal1D (hist[j]->bins, i),buf,fl_rgb_color(kRed[ci]*i,kGreen[ci]*i,kBlue[ci]*i));
}
}

void HistForm::Calculate() {
  float crange[] = { 0, 255 };  
  float *ranges[] = { crange };
  int hist_size = 256;
  int k=1;
  if(img->nChannels==3) 
    k=5;
  
  for(int i=0;i< k;i++)
    himg[i] = cvCreateImage (cvSize (img->width, img->height), img->depth, 1);


  if(img->nChannels==1){
    cvCopy (img, himg[0], NULL);  

  }
  else{
    cvSplit (img, himg[0], himg[1], himg[2], 0);  
    timg = cvCreateImage( cvGetSize(img), 8, 3 );
    cvCvtColor( img, timg, CV_RGB2HSV );
    cvSplit (timg, himg[3], 0, 0, 0);
    cvSplit (timg, 0, himg[4], 0, 0);
    cvReleaseImage (&timg);          
  }
  for(int i=0;i<k;i++){
     hist[i] = cvCreateHist (1, &hist_size, CV_HIST_ARRAY, ranges, 1);
     cvCalcHist (&himg[i], hist[i], 0, NULL);
  }
}
